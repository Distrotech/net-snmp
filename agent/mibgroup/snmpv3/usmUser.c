
/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#include <config.h>

#include "mibincl.h"
#include "snmpusm.h"
#include "snmpv3.h"

#include "usmUser.h"

static struct usmUser *userList=NULL;

void init_usmUser(void) {
  /* initialize the user list */
  userList = usm_create_initial_user();
}
  
/* given a user's information, generate the index OID for it */
oid *generate_OID(oid *prefix, int prefixLen, struct usmUser *uptr,
                  int *length) {
  oid *indexOid;
  int i;

  /* reference oid encoded as engineIDLen.engineID.nameLen.name */
  *length = 2 + uptr->engineIDLen + strlen(uptr->name) + prefixLen;
  indexOid = (oid *) malloc(*length * sizeof(oid));
  if (indexOid) {
    memmove(indexOid, prefix, prefixLen * sizeof (oid));

    indexOid[prefixLen] = uptr->engineIDLen;
    for(i = 0; i < uptr->engineIDLen; i++)
      indexOid[prefixLen+1+i] = (oid) uptr->engineID[i];

    indexOid[prefixLen + uptr->engineIDLen + 1] = strlen(uptr->name);
    for(i = 0; i < strlen(uptr->name); i++)
      indexOid[prefixLen + uptr->engineIDLen + 2 + i] = (oid) uptr->name[i];
  }
  return indexOid;
}

unsigned char *
var_usmUser(vp, name, length, exact, var_len, write_method)
    struct variable *vp;
    oid     *name;
    int     *length;
    int     exact;
    int     *var_len;
    int     (**write_method) __P((int, unsigned char *,unsigned char, int, unsigned char *,oid*, int));
{
  struct usmUser *uptr, *nptr, *pptr;
  char *userEngineID;
  int userEngineIDLen;
  char *userName;
  int i, rtest, result;
  oid *indexOid;
  int len;

  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;

  *write_method = 0;           /* assume it isnt writable for the time being */
  *var_len = sizeof(long_ret); /* assume an integer and change later if not */

  if (vp->magic != USMUSERSPINLOCK) {
#define MAX_NEWNAME_LEN 100
    oid newname[MAX_NEWNAME_LEN];
    for(i=0,rtest=0; i < (int) vp->namelen && i < (int)(*length) && !rtest; i++) {
      if (name[i] != vp->name[i]) {
        if (name[i] < vp->name[i]) 
          rtest = -1;
        else
          rtest = 1;
      }
    }
    if (rtest > 0 ||
        (rtest == 0 && !exact && (int) vp->namelen+1 < (int) *length) ||
        (exact == 1 && (rtest || *length != vp->namelen+1))) {
      if (var_len)
	*var_len = 0;
      return 0;
    }
    memset((char *) newname,(0),MAX_NEWNAME_LEN*sizeof(oid));
    if (((int) *length) <= (int) vp->namelen || rtest == -1) {
      /* oid is not within our range yet */
      /* need to fail if not exact */
      uptr = userList;
    } else {
      for(nptr = userList, pptr = NULL, uptr = NULL; nptr != NULL;
          pptr = nptr, nptr = nptr->next) {
        indexOid = generate_OID(vp->name, vp->namelen, nptr, &len);
        result = compare(name, *length, indexOid, len);
        DEBUGP("usmUser: Checking user: %s - ", nptr->name);
        for(i = 0; i < nptr->engineIDLen; i++)
          printf(" %x",nptr->engineID[i]);
        DEBUGP("\n  -> OID: ");
        DEBUGPOID(indexOid, len);
        DEBUGP("\n");
        if (exact) {
          if (result == 0) {
            free(indexOid);
            uptr = nptr;
            continue;
          }
        } else {
          if (result > 0) {
            free(indexOid);
            uptr = pptr;
            continue;
          } else if (result == 0) {
            /* found an exact match.  Need the next one for !exact */
            free(indexOid);
            uptr = nptr->next;
            continue;
          }
        }
        free(indexOid);
      }
    }
    /* if uptr is NULL and exact we need to continue for creates */
    if (uptr == NULL && !exact)
      return(NULL);

    if (uptr) {
      indexOid = generate_OID(vp->name, vp->namelen, uptr, &len);
      *length = len;
      memmove(name, indexOid, len*sizeof(oid));
      DEBUGP("usmUser: Found user: %s - ", uptr->name);
      for(i = 0; i < uptr->engineIDLen; i++)
        DEBUGP(" %x",uptr->engineID[i]);
      DEBUGP("\n  -> OID: ");
      DEBUGPOID(indexOid, len);
      DEBUGP("\n");
    } else {
      indexOid = NULL;
    }
  } else {
    return NULL;
  }

  switch(vp->magic) {
    case USMUSERSPINLOCK:
      *write_method = write_usmUserSpinLock;
      long_ret = 0;
      return (unsigned char *) &long_ret;

    case USMUSERSECURITYNAME:
      *var_len = strlen(uptr->secName);
      return (unsigned char *) uptr->secName;

    case USMUSERCLONEFROM:
      *write_method = write_usmUserCloneFrom;
      *var_len = uptr->cloneFromLen*sizeof(oid);
      return (unsigned char *) uptr->cloneFrom;

    case USMUSERAUTHPROTOCOL:
      *write_method = write_usmUserAuthProtocol;
      *var_len = uptr->authProtocolLen*sizeof(oid);
      return (unsigned char *) uptr->authProtocol;

    case USMUSERAUTHKEYCHANGE:
      *write_method = write_usmUserAuthKeyChange;
      *string = 0;
      *var_len = strlen(string);
      return (unsigned char *) string;

    case USMUSEROWNAUTHKEYCHANGE:
      *write_method = write_usmUserOwnAuthKeyChange;
      *string = 0;
      *var_len = strlen(string);
      return (unsigned char *) string;

    case USMUSERPRIVPROTOCOL:
      *write_method = write_usmUserPrivProtocol;
      objid[0] = 0;
      objid[1] = 0;
      *var_len = 2*sizeof(oid);
      return (unsigned char *) objid;

    case USMUSERPRIVKEYCHANGE:
      *write_method = write_usmUserPrivKeyChange;
      *string = 0;
      *var_len = strlen(string);
      return (unsigned char *) string;

    case USMUSEROWNPRIVKEYCHANGE:
      *write_method = write_usmUserOwnPrivKeyChange;
      *string = 0;
      *var_len = strlen(string);
      return (unsigned char *) string;

    case USMUSERPUBLIC:
      *write_method = write_usmUserPublic;
      *string = 0;
      *var_len = strlen(string);
      return (unsigned char *) string;

    case USMUSERSTORAGETYPE:
      *write_method = write_usmUserStorageType;
      long_ret = 0;
      return (unsigned char *) &long_ret;

    case USMUSERSTATUS:
      *write_method = write_usmUserStatus;
      long_ret = 0;
      return (unsigned char *) &long_ret;

    default:
      ERROR_MSG("");
  }
  return 0;
}

int
write_usmUserSpinLock(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_INTEGER){
      fprintf(stderr, "write to usmUserSpinLock not ASN_INTEGER\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(long_ret)){
      fprintf(stderr,"write to usmUserSpinLock: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(long_ret);
      asn_parse_int(var_val, &bigsize, &var_val_type, &long_ret, size);
      /* Here, the variable has been stored in long_ret for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserCloneFrom(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_OBJECT_ID){
      fprintf(stderr, "write to usmUserCloneFrom not ASN_OBJECT_ID\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(objid)){
      fprintf(stderr,"write to usmUserCloneFrom: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(objid);
      asn_parse_objid(var_val, &bigsize, &var_val_type, objid, &size);
      /* Here, the variable has been stored in objid for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserAuthProtocol(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_OBJECT_ID){
      fprintf(stderr, "write to usmUserAuthProtocol not ASN_OBJECT_ID\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(objid)){
      fprintf(stderr,"write to usmUserAuthProtocol: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(objid);
      asn_parse_objid(var_val, &bigsize, &var_val_type, objid, &size);
      /* Here, the variable has been stored in objid for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserAuthKeyChange(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_OCTET_STR){
      fprintf(stderr, "write to usmUserAuthKeyChange not ASN_OCTET_STR\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(string)){
      fprintf(stderr,"write to usmUserAuthKeyChange: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(string);
      asn_parse_string(var_val, &bigsize, &var_val_type, string, &size);
      /* Here, the variable has been stored in string for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserOwnAuthKeyChange(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_OCTET_STR){
      fprintf(stderr, "write to usmUserOwnAuthKeyChange not ASN_OCTET_STR\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(string)){
      fprintf(stderr,"write to usmUserOwnAuthKeyChange: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(string);
      asn_parse_string(var_val, &bigsize, &var_val_type, string, &size);
      /* Here, the variable has been stored in string for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserPrivProtocol(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_OBJECT_ID){
      fprintf(stderr, "write to usmUserPrivProtocol not ASN_OBJECT_ID\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(objid)){
      fprintf(stderr,"write to usmUserPrivProtocol: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(objid);
      asn_parse_objid(var_val, &bigsize, &var_val_type, objid, &size);
      /* Here, the variable has been stored in objid for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserPrivKeyChange(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_OCTET_STR){
      fprintf(stderr, "write to usmUserPrivKeyChange not ASN_OCTET_STR\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(string)){
      fprintf(stderr,"write to usmUserPrivKeyChange: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(string);
      asn_parse_string(var_val, &bigsize, &var_val_type, string, &size);
      /* Here, the variable has been stored in string for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserOwnPrivKeyChange(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_OCTET_STR){
      fprintf(stderr, "write to usmUserOwnPrivKeyChange not ASN_OCTET_STR\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(string)){
      fprintf(stderr,"write to usmUserOwnPrivKeyChange: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(string);
      asn_parse_string(var_val, &bigsize, &var_val_type, string, &size);
      /* Here, the variable has been stored in string for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserPublic(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_OCTET_STR){
      fprintf(stderr, "write to usmUserPublic not ASN_OCTET_STR\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(string)){
      fprintf(stderr,"write to usmUserPublic: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(string);
      asn_parse_string(var_val, &bigsize, &var_val_type, string, &size);
      /* Here, the variable has been stored in string for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserStorageType(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_INTEGER){
      fprintf(stderr, "write to usmUserStorageType not ASN_INTEGER\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(long_ret)){
      fprintf(stderr,"write to usmUserStorageType: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(long_ret);
      asn_parse_int(var_val, &bigsize, &var_val_type, &long_ret, size);
      /* Here, the variable has been stored in long_ret for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

int
write_usmUserStatus(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;
  int size, bigsize=1000;

  if (var_val_type != ASN_INTEGER){
      fprintf(stderr, "write to usmUserStatus not ASN_INTEGER\n");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof(long_ret)){
      fprintf(stderr,"write to usmUserStatus: bad length\n");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof(long_ret);
      asn_parse_int(var_val, &bigsize, &var_val_type, &long_ret, size);
      /* Here, the variable has been stored in long_ret for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}

