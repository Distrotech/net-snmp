#!/usr/bin/perl
#!/usr/bin/perl -w

#
# Description: 
#
# This program, given an OID reference as an argument, creates some
# template mib module files to be used with the ucd-snmp agent.  It is
# far from perfect and will not generate working modules, but it
# significantly shortens development time by outlining the basic
# structure.
#
# Its up to you to verify what it does and change the default values
# it returns.
#

use SNMP;
use FileHandle;

#use strict 'vars';
$SNMP::save_descriptions=1;
$SNMP::use_long_names=1;
$SNMP::use_enums=1;
SNMP::initMib();

$configfile="mib2c.conf";
$debug=0;
$quiet=0;
$nostats = 0;

sub usage {
    print "$0 [-h] [-c configfile] [-f prefix] mibNode\n\n";
    print "  -h\t\tThis message.\n\n";
    print "  -c configfile\tSpecifies the configuration file to use\n\t\tthat dictates what the output of mib2c will look like.\n\n";
    print "  -f prefix\tSpecifies the output prefix to use.  All code\n\t\twill be put into prefix.c and prefix.h\n\n";
    print "  mibNode\tThe name of the top level mib node you want to\n\t\tgenerate code for.  By default, the code will be stored in\n\t\tmibNode.c and mibNode.h (use the -f flag to change this)\n\n";
    print "  -d\t\tdebugging output (dont do it.  trust me.)\n\n";
    print "  -s\t\tDon't display statistics at the end\n\n";
    print "  -S VAR=VAL\tSet $VAR variable to $VAL\n";
    1;
}	

while($#ARGV >= 0) {
    $_ = shift;
    $configfile = shift if (/^-c/);
    $debug = 1 if (/^-d/);
    if (/-S/) {
	my $expr = shift;
	my ($var, $val) = ($expr =~ /([^=]*)=(.*)/);
	die "no variable specified for -S flag." if (!$var);
	$vars{$var} = $val;
    }
    $quiet = 1 if (/^-q/);
    $nostats = 1 if (/^-s/);
    usage && exit(1) if (/^-h/);
    $outputName = shift if (/^-f/);
    $oid = $_ if (/^[^-]/);
}
 
#
# internal conversion tables
#

%accessToIsWritable = qw(ReadOnly 0 ReadWrite 1 
			 WriteOnly 1 Create 1);
%perltoctypes = qw(OCTETSTR   ASN_OCTET_STR
		   INTEGER    ASN_INTEGER
		   INTEGER32  ASN_INTEGER
		   UNSIGNED32 ASN_UNSIGNED
		   OBJECTID   ASN_OBJECT_ID
		   COUNTER64  ASN_COUNTER64
		   COUNTER    ASN_COUNTER
		   NETADDR    ASN_COUNTER
		   UINTEGER   ASN_UINTEGER
		   IPADDR     ASN_IPADDRESS
		   BITS       ASN_IPADDRESS
		   TICKS      ASN_TIMETICKS
		   GAUGE      ASN_GAUGE
		   OPAQUE     ASN_OPAQUE);


my $mibnode = $SNMP::MIB{$oid};
die "you didn't give me a valid OID to start with" if (!$mibnode);

# setup
$outputName = $mibnode->{'label'} if (!defined($outputName));
$vars{'name'} = $outputName;
$vars{'oid'} = $oid;

# loop through mib nodes, remembering stuff.
setup_data($mibnode);

# process .conf file
$fh = new IO::File;
$fh->open("$configfile");
process();
$fh->close;

foreach $i (keys(%written)) {
    next if ($i eq "-");
    print STDERR "running indent on $i\n" if (!$quiet);
    system("indent -orig -nbc -bap -nut $i");
}

sub tocommas {
    my $oid = $_[0];
    $oid =~ s/\./,/g;
    $oid =~ s/^\s*,//;
    return $oid;
}

sub oidlength {
    return scalar ($_[0] =~ /\./);
}

# replaces $VAR type expressions and $VAR.subcomponent expressions
# with data from the mib tree and loop variables.
# possible uses:
#
#   $var               -- as defined by loops, etc.
#   ${var}otherstuff   -- appending text to variable contents
#   $var.uc            -- all upper case version of $var
#
# Mib components, $var must first expand to a mib node name:
#
#   $var.objectID      -- dotted full OID
#   $var.commaoid      -- comma separated OID for array init
#   $var.subid         -- last number component of oid
#   $var.oidlength     -- length of the oid
#   $var.type          -- node's ASN_XXX type
#   $var.settable      -- 1 if it's writable, 0 if not
#   $var.access        -- node's access type
#   $var.status        -- node's status
#   $var.syntax        -- node's syntax
sub process_vars {
    my $it = shift;

    # mib substitutions ($var.type -> $mibnode->{'type'})
    $it =~ s/\$(\w+)\.(uc)/uc($vars{$1})/eg; # make something uppercase
    $it =~ s/\$(\w+)\.(commaoid)/tocommas($SNMP::MIB{$vars{$1}}{objectID})/eg; # lowercase
    $it =~ s/\$(\w+)\.(oidlength)/oidlength($SNMP::MIB{$vars{$1}}{objectID})/eg; # lowercase
    $it =~ s/\$(\w+)\.(perltype)/$SNMP::MIB{$vars{$1}}{type}/g; # lowercase
    $it =~ s/\$(\w+)\.(type)/$perltoctypes{$SNMP::MIB{$vars{$1}}{$2}}/g; # lowercase
    $it =~ s/\$(\w+)\.(subid)/$SNMP::MIB{$vars{$1}}{subID}/g; # lowercase
    $it =~ s/\$(\w+)\.(settable)/(($SNMP::MIB{$vars{$1}}{access} =~ \/(ReadWrite|Create|Writeonly)\/)?1:0)/eg; # lowercase
    $it =~ s/\$(\w+)\.(objectID|label|subID|access|status|syntax)/$SNMP::MIB{$vars{$1}}{$2}/g;

    # normal variable substitions
    $it =~ s/\$\{(\w+)\}/$vars{$1}/g;
    $it =~ s/\$(\w+)/$vars{$1}/g;
    return $it;
}

# process various types of statements
#
# which include:
#   @open FILE@
#     writes generated output to FILE
#   @foreach $VAR table@
#     repeat iterate over code until @end@ setting $VAR to all known tables
#   @foreach $VAR column@
#     repeat iterate over code until @end@ setting $VAR to all known
#     columns within a given table.  Obviously this must be called
#     within a foreach-table clause.
#   @foreach $VAR index@
#     repeat iterate over code until @end@ setting $VAR to all known
#     indexes within a given table.  Obviously this must be called
#     within a foreach-table clause.
#   @eval $VAR = expression@
#     evaluates expression and assigns the results to $VAR
#   @perleval STUFF@
#     evaluates STUFF directly in perl.  Note that all mib2c variables
#     interpereted within .conf files are in $vars{NAME}.
#   @skip@
#     skips everything till the appropriately matched @end@
#   @if expression@
#      evaluates expression, and if expression is true processes
#      contained part until appropriate @end@ is reached.
sub skippart {
    my $endcount = 1;
    while(<$fh>) {
	if (/\@end\@/) {
	    return if ($endcount == 1);
	    $endcount--;
	}
	if (/\@else\@/) {
	    return if ($endcount == 1);
	}
	if (/\@(foreach|if)/) {
	    $endcount++;
	}
    }
}


sub process {
    while(<$fh>) {
	if (/^\#\#/) {
	    # noop, it's a comment
	} elsif (/\@open\s+([^\@]+)\@/) {
	    my $spec = process_vars($1);
	    $out->close() if ($out);
	    $out = new IO::File;
	    $out->open(">$spec") || die "failed to open $spec";
	    print STDERR "writing to $spec\n" if (!$quiet);
	    $written{$spec} = '1';
	} elsif (/\@end\@/) {
	    return;
	} elsif (/\@if\s+([^@]*)\@/) {
	    if (eval(process_vars($1))) {
		process();
	    } else {
		skippart();
	    }
	} elsif (/\@eval\s+\$(\w+)\s*=\s*([^\@]*)/) {
	    my ($v, $e) = ($1, $2);
	    my $e = process_vars($e);
	    $vars{$v} = eval($e);
	} elsif (/\@perleval\s*(.*)\@/) {
	    eval($1);
	} elsif (/\@skip\@/) {
	    skippart();
	} elsif (/\@\s*foreach\s+\$([^\@]+)\s+tables*\s*\@/) {
	    my $var = $1;
	    my $startpos = tell(C);
	    my $table;
	    foreach $table (keys %tables) {
		seek(C, $startpos, 0); # go to top of section.
		my $oldvar = $vars{$var};
		$vars{$var} = $table;
		my $oldtable = $currenttable;
		$currenttable = $table;
		process();
		$vars{$var} = $oldvar;
		$currenttable = $oldtable;
	    }
	} elsif (/\@\s*foreach\s+\$([^\@]+)\s+(column|index)\s*\@/) {
	    my ($var, $type) = ($1, $2);
	    my $startpos = $fh->tell();
	    my $column;
	    foreach $column (@{$tables{$currenttable}{$type}}) {
#		print "looping on $var for $type -> $column\n";
		$fh->seek($startpos, 0); # go to top of section.
		my $oldvar = $vars{$var};
		$vars{$var} = $column;
		my $oldcolumn = $currentcolumn;
		$currentcolumn = $column;
		process();
		$vars{$var} = $oldvar;
		$currentcolumn = $oldcolumn;
	    }
	} else {
	    die "no output file specified" if (!$out);
	    print $out process_vars($_);
	}
    }
}

sub setup_data {
    my $mib = shift;
    if ($mib->{label} =~ /Table$/) {
	my $tablename = $mib->{label};
	my $entry = $mib->{children};
	my $columns = $entry->[0]{children};
	foreach my $col (sort { $a->{'subID'} <=> $b->{'subID'} } @$columns) {
	    # store by numeric key so we can sort them later
	    push @{$tables{$tablename}{'column'}}, $col->{'label'};
	}
	foreach my $index (@{$entry->[0]{'indexes'}}) {
	    my $node = $SNMP::MIB{$index} || 
		die "can't find info about index $index in table $tablename\n";
	    push @{$tables{$tablename}{'index'}}, $index;
	}
    } else {
	my $children = $mib->{children};
	my $i;
	for($i = 0; $i <= $#$children; $i++) {
	    setup_data($children->[$i]);
	}
    }
}

sub min {
    return $_[0] if ($_[0] < $_[1]);
    return $_[1];
}

sub max {
    return $_[0] if ($_[0] > $_[1]);
    return $_[1];
}
