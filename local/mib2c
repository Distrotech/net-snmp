#!/usr/bin/perl
#!/usr/bin/perl -w

#
# Description: 
#
# This program, given an OID reference as an argument, creates some
# template mib module files to be used with the ucd-snmp agent.  It is
# far from perfect and will not generate working modules, but it
# significantly shortens development time by outlining the basic
# structure.
#
# Its up to you to verify what it does and change the default values
# it returns.
#

use SNMP;
use FileHandle;

#use strict 'vars';
$SNMP::save_descriptions=1;
$SNMP::use_long_names=1;
$SNMP::use_enums=1;
SNMP::initMib();

$configfile="mib2c.conf";
$debug=0;
$nostats = 0;

sub usage {
    print "$0 [-h] [-c configfile] [-f prefix] mibNode\n\n";
    print "  -h\t\tThis message.\n\n";
    print "  -c configfile\tSpecifies the configuration file to use\n\t\tthat dictates what the output of mib2c will look like.\n\n";
    print "  -f prefix\tSpecifies the output prefix to use.  All code\n\t\twill be put into prefix.c and prefix.h\n\n";
    print "  mibNode\tThe name of the top level mib node you want to\n\t\tgenerate code for.  By default, the code will be stored in\n\t\tmibNode.c and mibNode.h (use the -f flag to change this)\n\n";
    print "  -d\t\tdebugging output (dont do it.  trust me.)\n\n";
    print "  -s\t\tDon't display statistics at the end\n\n";
    1;
}	

while($#ARGV >= 0) {
    $_ = shift;
    $configfile = shift if (/^-c/);
    $debug = 1 if (/^-d/);
    $nostats = 1 if (/^-s/);
    usage && exit(1) if (/^-h/);
    $outputName = shift if (/^-f/);
    $oid = $_ if (/^[^-]/);
}
 
#
# internal conversion tables
#

%accessToUCD = qw(ReadOnly RONLY ReadWrite RWRITE 
		  WriteOnly RWRITE Create RWRITE);

%accessToIsWritable = qw(ReadOnly 0 ReadWrite 1 
			 WriteOnly 1 Create 1);
%perltoctypes = qw(OCTETSTR   ASN_OCTET_STR
		   INTEGER    ASN_INTEGER
		   INTEGER32  ASN_INTEGER
		   UNSIGNED32 ASN_UNSIGNED
		   OBJECTID   ASN_OBJECT_ID
		   COUNTER64  ASN_COUNTER64
		   COUNTER    ASN_COUNTER
		   NETADDR    ASN_COUNTER
		   UINTEGER   ASN_UINTEGER
		   IPADDR     ASN_IPADDRESS
		   BITS       ASN_IPADDRESS
		   GAUGE      ASN_GAUGE
		   OPAQUE     ASN_OPAQUE);


my $mibnode = $SNMP::MIB{$oid};
die "you didn't give me a valid OID to start with" if (!$mibnode);

# setup
$outputName = $mibnode->{'label'} if (!defined($outputName));
$vars{'name'} = $outputName;
$vars{'oid'} = $oid;

# loop through mib nodes, remembering stuff.
setup_data($mibnode);

# process .conf file
$fh = new IO::File;
$fh->open("$configfile");
process();
$fh->close;

foreach $i (keys(%written)) {
    print STDERR "running indent on $i\n";
    system("indent -orig -nbc -bap -nut $i");
}

sub tocommas {
    my $oid = $_[0];
    $oid =~ s/\./,/g;
    $oid =~ s/^\s*,//;
    return $oid;
}

sub oidlength {
    return scalar ($_[0] =~ /\./);
}

# replaces $VAR type expressions and $VAR.subcomponent expressions
# with data from the mib tree and loop variables.
# possible uses:
#
#   $var               -- as defined by loops, etc.
#   ${var}otherstuff   -- appending text to variable contents
#   $var.uc            -- all upper case version of $var
#
# Mib components, $var must first expand to a mib node name:
#
#   $var.objectID      -- dotted full OID
#   $var.commaoid      -- comma separated OID for array init
#   $var.subid         -- last number component of oid
#   $var.oidlength     -- length of the oid
#   $var.type          -- node's ASN_XXX type
#   $var.settable      -- 1 if it's writable, 0 if not
#   $var.access        -- node's access type
#   $var.status        -- node's status
#   $var.syntax        -- node's syntax
sub process_vars {
    my $it = shift;

    # mib substitutions ($var.type -> $mibnode->{'type'})
    $it =~ s/\$(\w+)\.(uc)/uc($vars{$1})/eg; # make something uppercase
    $it =~ s/\$(\w+)\.(commaoid)/tocommas($SNMP::MIB{$vars{$1}}{objectID})/eg; # lowercase
    $it =~ s/\$(\w+)\.(oidlength)/oidlength($SNMP::MIB{$vars{$1}}{objectID})/eg; # lowercase
    $it =~ s/\$(\w+)\.(type)/$perltoctypes{$SNMP::MIB{$vars{$1}}{$2}}/g; # lowercase
    $it =~ s/\$(\w+)\.(subid)/$SNMP::MIB{$vars{$1}}{subID}/g; # lowercase
    $it =~ s/\$(\w+)\.(setable)/(($SNMP::MIB{$vars{$1}}{access} =~ \/(ReadWrite|Create|Writeonly)\/)?1:0)/eg; # lowercase
    $it =~ s/\$(\w+)\.(objectID|label|subID|access|status|syntax)/$SNMP::MIB{$vars{$1}}{$2}/g;

    # normal variable substitions
    $it =~ s/\$\{(\w+)\}/$vars{$1}/g;
    $it =~ s/\$(\w+)/$vars{$1}/g;
    return $it;
}

sub process {
    while(<$fh>) {
	if (/\@open\s+([^\@]+)\@/) {
	    my $spec = process_vars($1);
	    $out->close() if ($out);
	    $out = new IO::File;
	    $out->open(">$spec") || die "failed to open $spec";
	    print STDERR "writing to $spec\n";
	    $written{$spec} = '1';
	} elsif (/\@end\@/) {
	    return;
	} elsif (/\@\s*foreach\s+\$([^\@]+)\s+table\s*\@/) {
	    my $var = $1;
	    my $startpos = tell(C);
	    my $table;
	    foreach $table (keys %tables) {
		seek(C, $startpos, 0); # go to top of section.
		my $oldvar = $vars{$var};
		$vars{$var} = $table;
		my $oldtable = $currenttable;
		$currenttable = $table;
		process();
		$vars{$var} = $oldvar;
		$currenttable = $oldtable;
	    }
	} elsif (/\@\s*foreach\s+\$([^\@]+)\s+(column|index)\s*\@/) {
	    my ($var, $type) = ($1, $2);
	    my $startpos = $fh->tell();
	    my $column, @columns;
	    @columns = sort { $a <=> $b } keys %{$tables{$currenttable}{$type}};
#	    print "looping in table $currenttable $var = $type, #=", $#columns, ": ",$tables{$currenttable}{$type . "s"},"\n";
	    foreach $column (@columns) {
#		print "looping on $var for $type -> $column\n";
		$fh->seek($startpos, 0); # go to top of section.
		my $oldvar = $vars{$var};
		$vars{$var} = $tables{$currenttable}{$type}{$column};
		my $oldcolumn = $currentcolumn;
		$currentcolumn = $tables{$currenttable}{$type}{$column};
		process();
		$vars{$var} = $oldvar;
		$currentcolumn = $oldcolumn;
	    }
#	    print "done looping $var = $type\n";
	} else {
	    die "no output file specified" if (!$out);
	    print $out process_vars($_);
	}
    }
}

sub setup_data {
    my $mib = shift;
    if ($mib->{label} =~ /Table$/) {
	my $tablename = $mib->{label};
	my $entry = $mib->{children};
	my $columns = $entry->[0]{children};
	foreach my $col (@$columns) {
	    # store by numeric key so we can sort them later
	    $tables{$tablename}{'column'}{$col->{subID}} = $col->{'label'};
	}
	foreach my $index (@{$entry->[0]{'indexes'}}) {
	    my $node = $SNMP::MIB{$index} || 
		die "can't find info about index $index in table $tablename\n";
	    $tables{$tablename}{'index'}{$node->{subID}} = $index;
	}
    } else {
	my $children = $mib->{children};
	my $i;
	for($i = 0; $i <= $#$children; $i++) {
	    setup_data($children->[$i]);
	}
    }
}
