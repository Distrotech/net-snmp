## -*- c -*-
######################################################################
## Do the .h file
######################################################################
@foreach $i table@
@open include/${i}_user.h@
/*
 * Note: this file originally auto-generated by mib2c using
 *       $Id$
 */
#ifndef ${i}_user_H
#define ${i}_user_H

#include "net-snmp/oid_array.h"
#include "net-snmp/table_array.h"

typedef struct ${i}_context_s {
    oid_array_header index; /** THIS MUST BE FIRST!!! */

    /*
     * You can store data internally in this structure. You'll
     * probably have to fix a few types here...
     */
    @foreach $c column@
    int    $c.uc;
    @end@

    /*
     * OR
     *
     * Keep a pointer to your data
     */
    void * data;

    /*
     *add anything else you want here
     */

} ${i}_context;

int ${i}_get_value(request_info *, oid_array_header *,
                   table_request_info *);

/* uncomment the following line if you are handling SET-REQUEST for $i */
/** #define ${i}_SET_HANDLING */

/* uncomment the following line if you can create new rows */
/** #define ${i}_ROW_CREATION */

#ifdef ${i}_SET_HANDLING
void ${i}_set_reserve1( array_group * );
void ${i}_set_reserve2( array_group * );
void ${i}_set_action( array_group * );
void ${i}_set_commit( array_group * );
void ${i}_set_free( array_group * );
void ${i}_set_undo( array_group * );
#endif

#ifdef ${i}_ROW_CREATION
oid_array_header * ${i}_create_row( oid_array_header* );
oid_array_header * ${i}_delete_row( oid_array_header* );
#endif

/**
  And just for your enjoyment:
  
    @foreach $c column@
name                 : $c
uppercase            : $c.uc
dotted full OID      : $c.objectID
comma separated OID  : $c.commaoid
last component of oid: $c.subid
length of the oid    : $c.oidlength
node's ASN_XXX type  : $c.type
1 if it's writable   : $c.settable
node's access type   : $c.access
node's status        : $c.status
node's syntax        : $c.syntax

    @end@
*/

#endif /** ${i}_user_H */
@end@
######################################################################
## Do the .c file
######################################################################
@foreach $i table@
@open user/${name}_user.c@
/*
 * Note: this file originally auto-generated by mib2c using
 *       $Id$
 */
#ifdef IN_UCD_SNMP_SOURCE
/** If we're compiling this file inside the ucd-snmp source tree */

/** This should always be included first before anything else */
#include <config.h>

/** minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"
#include "table.h"

#else /** !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif /** !IN_UCD_SNMP_SOURCE */

#include "${i}.h"


/************************************************************
 * ${i}_get_value
 */
int ${i}_get_value(
            request_info *request,
            oid_array_header *item,
            table_request_info *table_info )
{
    struct variable_list *var = request->requestvb;
    ${i}_context *context = (${i}_context *)item;

    switch(table_info->colnum) {

        @foreach $c column@
        case COLUMN_$c.uc:
            snmp_set_var_typed_value(var, $c.type,
                         (char*)&context->$c.uc,
                         sizeof(context->$c.uc) );
        break;

        @end@
    default: /** We shouldn't get here */
        snmp_log(LOG_ERR, "unknown column in "
                 "${i}_get_value\n");
    }
}

#ifdef ${i}_SET_HANDLING

#ifdef ${i}_ROW_CREATION
oid_array_header *
${i}_create_row( oid_array_header* )
{
    ${i}_context * ctx =
        (${i}_context*)calloc(1,sizeof(*ctx));
    if(!ctx)
        return NULL;

    if(snmp_clone_mem( &ctx->index->idx, hdr->idx,
                       hdr->idx_len * sizeof(oid) )) {
        free(ctx);
        return NULL;
    }
    ctx->index->idx_len = hdr->idx_len;

    return ctx;
}
#endif


/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 */
void ${i}_set_reserve1( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag->new_row;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
            if( var->type != $c.type ) {
                set_mode_request_error(MODE_SET_BEGIN, current->ri,
                                       SNMP_ERR_WRONGTYPE );
            }
            else if( var->val_len != sizeof(context->$c) ) {
                set_mode_request_error(MODE_SET_BEGIN, current->ri,
                                       SNMP_ERR_WRONGLENGTH );
            }
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_reserve1\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

void ${i}_set_reserve2( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag->new_row;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
            if ( var->val.XXX != XXX ) {
                /** or SNMP_ERR_INCONSISTENTVALUE */
                set_mode_request_error(MODE_SET_BEGIN, current->ri,
                                       SNMP_ERR_BADVALUE );
            }
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_reserve2\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */

}

/************************************************************
 * Assuming that the RESERVE phase was successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 */
void ${i}_set_action( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag->new_row;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_action\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 */
void ${i}_set_commit( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag->new_row;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_commit\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If any of these calls fail (in either pass) the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 */          
void ${i}_set_free( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag->new_row;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_free\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 */
void ${i}_set_undo( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag->new_row;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_undo\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}
@end@
#endif /** ${i}_SET_HANDLING */
@end@
