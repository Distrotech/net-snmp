## -*- c -*-
######################################################################
## Do the .h file
######################################################################
@foreach $i table@
@open include/${i}_user.h@
/*
 * Note: this file originally auto-generated by mib2c using
 *       $Id$
 */
#ifndef ${i}_user_H
#define ${i}_user_H

#include "net-snmp/oid_array.h"
#include "net-snmp/table_array.h"

typedef struct ${i}_context_s {
    oid_array_header index; /** THIS MUST BE FIRST!!! */

    /** XXX add anything you want here */
    void * data;
} ${i}_context;

int ${i}_get_value(request_info *, oid_array_header *,
                   table_request_info *);

/* uncomment the following line if you are handling SET-REQUEST for $i */
/** #define ${i}_SET_HANDLING */

#ifdef ${i}_SET_HANDLING
void ${i}_set_reserve1( array_group * );
void ${i}_set_reserve2( array_group * );
void ${i}_set_action( array_group * );
void ${i}_set_commit( array_group * );
void ${i}_set_free( array_group * );
void ${i}_set_undo( array_group * );
#endif

#endif /** ${i}_user_H */
@end@
######################################################################
## Do the .c file
######################################################################
@foreach $i table@
@open user/${name}_user.c@
/*
 * Note: this file originally auto-generated by mib2c using
 *       $Id$
 */
#ifdef IN_UCD_SNMP_SOURCE
/** If we're compiling this file inside the ucd-snmp source tree */

/** This should always be included first before anything else */
#include <config.h>

/** minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else /** !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif /** !IN_UCD_SNMP_SOURCE */

#include "${i}.h"


/************************************************************
 * ${i}_get_value
 */
int ${i}_get_value(
            request_info *request,
            oid_array_header *item,
            table_request_info *table_info )
{
    struct variable_list *var = request->requestvb;
    ${i}_context *context = (${i}_context *)item;

    switch(table_info->colnum) {

        @foreach $c column@
        case COLUMN_$c.uc:
            snmp_set_var_typed_value(var, $c.type,
                         /** XXX: data */,
                         /** XXX: length */);
        break;

@end@
    default: /** We shouldn't get here */
        snmp_log(LOG_ERR, "unknown column in "
                 "${i}_get_value\n");
    }
}

#ifdef ${i}_SET_HANDLING
/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 */
void ${i}_set_reserve1( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag;
    array_group_item *current;

    if(ag->row == NULL) {
        /*
         * if you can create new rows, do it here.
         */
        set_mode_request_error(MODE_SET_BEGIN, current->ri,
                               SNMP_ERR_NOCREATION);
    }

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
            /** check syntax - SNMP_ERR_WRONGTYPE */
            /** check range - SNMP_ERR_BADVALUE, SNMP_ERR_WRONGLENGTH */
            /** check allowable values - SNMP_ERR_INCONSISTENTVALUE */
            /** set_mode_request_error(MODE_SET_BEGIN, current->ri, SNMP_ERR_NOSUCHINSTANCE); */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_reserve1\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

void ${i}_set_reserve2( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_reserve2\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */

}

/************************************************************
 * Assuming that the RESERVE phase was successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 */
void ${i}_set_action( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_action\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 */
void ${i}_set_commit( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_commit\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If any of these calls fail (in either pass) the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 */          
void ${i}_set_free( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_free\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 */
void ${i}_set_undo( array_group *ag )
{
    struct variable_list *var;
    ${i}_context *context = (${i}_context *)ag;
    array_group_item *current;

    /*
     * loop through columns
     */
    for( current = ag->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        @foreach $c column@
        @if $c.settable@
        case COLUMN_$c.uc: /** $c.type */
        break;

        @end@
        @end@
        default: /** We shouldn't get here */
            snmp_log(LOG_ERR, "unknown column in "
                     "${i}_set_undo\n");
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}
@end@
#endif /** ${i}_SET_HANDLING */
@end@
